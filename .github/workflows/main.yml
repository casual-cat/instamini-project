name: DevOps Final Project

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest

    steps:
      # 1) Check out the code
      - name: Checkout repository
        uses: actions/checkout@v3

      # 2) Debug listing
      - name: List repository structure (debug)
        run: |
          echo "Listing root directory:"
          ls -la
          echo "Listing contents of 'terraform' folder:"
          ls -la terraform || echo "'terraform' folder not found"

      # 3) Install Dependencies
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y apt-transport-https ca-certificates gnupg curl jq unzip python3-pip

          # Terraform
          TF_VERSION="1.4.6"
          curl -sSL "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip" -o terraform.zip
          rm -rf tfbin
          unzip -o terraform.zip -d tfbin
          sudo mv tfbin/terraform /usr/local/bin/terraform
          sudo chmod +x /usr/local/bin/terraform
          export PATH="/usr/local/bin:$PATH"
          rm -rf tfbin terraform.zip
          terraform -version

          # Google Cloud CLI
          echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" \
            | sudo tee /etc/apt/sources.list.d/cloud-sdk.list
          curl https://packages.cloud.google.com/apt/doc/apt-key.gpg \
            | sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
          sudo apt-get update && sudo apt-get install -y google-cloud-cli

          # kubectl
          sudo apt-get install -y kubectl

          # helm
          HELM_VERSION="v3.12.0"
          curl -sSL "https://get.helm.sh/helm-${HELM_VERSION}-linux-amd64.tar.gz" -o helm.tar.gz
          tar xvf helm.tar.gz
          sudo mv linux-amd64/helm /usr/local/bin/helm

          # Python requirements
          pip3 install --upgrade pip
          pip3 install -r requirements.txt || true

      # 4) GCP Auth
      - name: GCP Auth
        run: |
          echo '${{ secrets.GCP_SA_KEY }}' | base64 --decode > /tmp/gcp-key.json
          gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
          gcloud config set project ${{ secrets.GCP_PROJECT_ID }}

      # 5) Test Python App
      - name: Test Python App
        env:
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_PORT: ${{ secrets.MYSQL_PORT }}
          MYSQL_USER: ${{ secrets.MYSQL_USER }}
          MYSQL_PASS: ${{ secrets.MYSQL_PASS }}
          MYSQL_DB:   ${{ secrets.MYSQL_DB }}
        run: |
          python3 -m unittest discover -s tests

      # 6) Terraform Init/Plan/Apply
      - name: Terraform Init/Plan/Apply
        env:
          TF_VAR_gcp_project: ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_gcp_region: ${{ secrets.GCP_REGION }}
          TF_VAR_gcp_zone: ${{ secrets.GCP_ZONE }}
          TF_VAR_vault_gcp_sa_key_b64: ${{ secrets.VAULT_GCP_SA_KEY_B64 }}
          TF_VAR_kms_key_ring: ${{ secrets.KMS_KEY_RING }}
          TF_VAR_kms_crypto_key: ${{ secrets.KMS_CRYPTO_KEY }}
          TF_VAR_db_root_password: ${{ secrets.DB_ROOT_PASSWORD }}
          TF_VAR_cloud_sql_instance_name: ${{ secrets.CLOUD_SQL_INSTANCE_NAME }}
        run: |
          cd terraform
          terraform init -backend-config="path=/tmp/terraform.tfstate"
          terraform plan
          terraform apply -auto-approve

      # 7) Create Kubernetes MySQL Secret
      - name: Create Kubernetes MySQL Secret
        run: |
          gcloud container clusters get-credentials vault-ha-cluster \
            --zone ${{ secrets.GCP_ZONE }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

          kubectl delete secret mysite-db-secrets -n default --ignore-not-found=true
          kubectl create secret generic mysite-db-secrets -n default \
            --from-literal=MYSQL_HOST=${{ secrets.MYSQL_HOST }} \
            --from-literal=MYSQL_PORT=${{ secrets.MYSQL_PORT }} \
            --from-literal=MYSQL_USER=${{ secrets.MYSQL_USER }} \
            --from-literal=MYSQL_PASS=${{ secrets.MYSQL_PASS }} \
            --from-literal=MYSQL_DB=${{ secrets.MYSQL_DB }}

      # 8) Docker Build & Push
      - name: Docker Build & Push
        uses: docker/build-push-action@v2
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/instamini:v3
          platforms: linux/amd64
        env:
          DOCKER_LOGIN_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKER_LOGIN_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}

      # 9) Configure kubectl (again, just to be safe)
      - name: Configure kubectl
        run: |
          gcloud container clusters get-credentials vault-ha-cluster \
            --zone ${{ secrets.GCP_ZONE }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      # 10) Install Argo CD & Create App
      - name: Install Argo CD
        run: |
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl rollout status deployment argocd-server -n argocd --timeout=300s

          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/argocd

          # Wait for Argo CD server to be ready
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd

          # Get Argo CD initial admin password
          ARGOCD_PW=$(kubectl -n argocd get secret argocd-initial-admin-secret \
            -o jsonpath="{.data.password}" | base64 -d)

          # Login
          argocd login argocd-server.argocd.svc.cluster.local:443 \
            --username admin \
            --password "$ARGOCD_PW" \
            --insecure --grpc-web

          # Create the Argo CD application to deploy the Helm chart
          argocd app create instamini \
            --repo https://github.com/casual-cat/instamini-project.git \
            --path helm/instamini \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace default \
            --sync-policy automated \
            --helm-set image.repository=${{ secrets.DOCKERHUB_USERNAME }}/instamini \
            --helm-set image.tag=v3 \
            --upsert \
            --insecure \
            --grpc-web

          # Wait for creation
          argocd app wait instamini --operation --timeout=300 --insecure --grpc-web

          # Sync
          argocd app sync instamini --insecure --grpc-web
          argocd app wait instamini --sync --health --timeout=300 --insecure --grpc-web

      # 11) Print External IP
      - name: Print External IP
        run: |
          for i in {1..10}; do
            EXTERNAL_IP=$(kubectl get svc instamini-mysite -n default -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$EXTERNAL_IP" ]; then
              echo "App is accessible at: http://$EXTERNAL_IP"
              exit 0
            fi
            echo "No external IP yet, waiting 30s..."
            sleep 30
          done
          echo "No external IP assigned after 10 tries."
          exit 1
