name: DevOps Final Project

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest
    env:
      GOOGLE_APPLICATION_CREDENTIALS: ${{ github.workspace }}/gcp-key.json

    steps:
      ############################################################
      # 1) Check out code
      ############################################################
      - name: Check out repository
        uses: actions/checkout@v3

      ############################################################
      # 2) Debug listing
      ############################################################
      - name: List repository
        run: |
          echo "Root directory:"
          ls -la
          echo "Terraform folder:"
          ls -la terraform || true

      ############################################################
      # 3) Install Dependencies
      ############################################################
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y apt-transport-https ca-certificates gnupg curl jq unzip python3-pip
          # ... your other installations (Terraform, gcloud CLI, kubectl, helm, vault, etc.)
          terraform -version

      ############################################################
      # 4) GCP Auth
      ############################################################
      - name: GCP Auth
        run: |
          echo '${{ secrets.GCP_SA_KEY }}' | base64 --decode > $GITHUB_WORKSPACE/gcp-key.json
          gcloud auth activate-service-account --key-file=$GITHUB_WORKSPACE/gcp-key.json
          gcloud config set project ${{ secrets.GCP_PROJECT_ID }}

      ############################################################
      # 5) Terraform Import KeyRing (Optional)
      ############################################################
      - name: Terraform Import Keyring
        run: |
          cd terraform
          terraform init -backend-config="bucket=tfstate-bucket-instamini" \
                         -backend-config="prefix=terraform/state"
          terraform import google_kms_key_ring.vault_ring \
            projects/${{ secrets.GCP_PROJECT_ID }}/locations/${{ secrets.GCP_REGION }}/keyRings/${{ secrets.KMS_KEY_RING }} \
            || echo "KeyRing doesn't exist or already imported"

      ############################################################
      # 6) Test Python App (Optional)
      ############################################################
      - name: Test Python App
        env:
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_PORT: ${{ secrets.MYSQL_PORT }}
          MYSQL_USER: ${{ secrets.MYSQL_USER }}
          MYSQL_PASS: ${{ secrets.MYSQL_PASS }}
          MYSQL_DB:   ${{ secrets.MYSQL_DB }}
        run: |
          python3 -m unittest discover -s tests

      ############################################################
      # 7A) Check if GKE cluster exists
      ############################################################
      - name: Check if cluster exists
        id: clustercheck
        run: |
          EXISTING=$(gcloud container clusters list --filter="name=vault-ha-cluster" --format="value(name)" || true)
          if [ "$EXISTING" == "vault-ha-cluster" ]; then
            echo "cluster_exists=true" >> $GITHUB_OUTPUT
          else
            echo "cluster_exists=false" >> $GITHUB_OUTPUT
          fi

      ############################################################
      # 7B) Conditionally create cluster+nodepool
      ############################################################
      - name: Terraform Apply (Create Cluster)
        if: steps.clustercheck.outputs.cluster_exists == 'false'
        env:
          TF_VAR_gcp_project: ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_gcp_region:  ${{ secrets.GCP_REGION }}
          TF_VAR_gcp_zone:    ${{ secrets.GCP_ZONE }}
          TF_VAR_vault_gcp_sa_key_b64: ${{ secrets.VAULT_GCP_SA_KEY_B64 }}
          TF_VAR_kms_key_ring: ${{ secrets.KMS_KEY_RING }}
          TF_VAR_kms_crypto_key: ${{ secrets.KMS_CRYPTO_KEY }}
          TF_VAR_cloud_sql_instance_name: ${{ secrets.CLOUD_SQL_INSTANCE_NAME }}
          TF_VAR_db_root_password: ${{ secrets.DB_ROOT_PASSWORD }}
        run: |
          cd terraform
          terraform init -backend-config="bucket=tfstate-bucket-instamini" \
                         -backend-config="prefix=terraform/state"
          terraform apply \
            -target=google_container_cluster.primary \
            -target=google_container_node_pool.primary_nodes \
            -auto-approve

      ############################################################
      # 7C) Configure Kubeconfig
      ############################################################
      - name: Configure Kubeconfig
        run: |
          gcloud container clusters get-credentials vault-ha-cluster \
            --zone ${{ secrets.GCP_ZONE }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      ############################################################
      # *OPTIONAL* (Approach #2) Force re-run the vault_init_and_config
      ############################################################
      # Uncomment this step if you want to ALWAYS re-run the local-exec script
      # - name: Force re-run Vault Init
      #   run: |
      #     cd terraform
      #     terraform taint null_resource.vault_init_and_config || echo "Nothing to taint"

      ############################################################
      # 7D) Terraform Apply (KMS + Vault + local-exec init)
      ############################################################
      - name: Terraform Apply (KMS + Vault)
        env:
          TF_VAR_gcp_project: ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_gcp_region: ${{ secrets.GCP_REGION }}
          TF_VAR_gcp_zone: ${{ secrets.GCP_ZONE }}
          TF_VAR_vault_gcp_sa_key_b64: ${{ secrets.VAULT_GCP_SA_KEY_B64 }}
          TF_VAR_kms_key_ring: ${{ secrets.KMS_KEY_RING }}
          TF_VAR_kms_crypto_key: ${{ secrets.KMS_CRYPTO_KEY }}
          TF_VAR_cloud_sql_instance_name: ${{ secrets.CLOUD_SQL_INSTANCE_NAME }}
          TF_VAR_db_root_password: ${{ secrets.DB_ROOT_PASSWORD }}
        run: |
          cd terraform
          terraform apply -auto-approve

      ############################################################
      # 8) Create MySQL Secret (for your app)
      ############################################################
      - name: Create MySQL Secret
        run: |
          gcloud container clusters get-credentials vault-ha-cluster --zone ${{ secrets.GCP_ZONE }} --project ${{ secrets.GCP_PROJECT_ID }}
          kubectl delete secret mysite-db-secrets -n default --ignore-not-found=true
          kubectl create secret generic mysite-db-secrets -n default \
            --from-literal=MYSQL_HOST=${{ secrets.MYSQL_HOST }} \
            --from-literal=MYSQL_PORT=${{ secrets.MYSQL_PORT }} \
            --from-literal=MYSQL_USER=${{ secrets.MYSQL_USER }} \
            --from-literal=MYSQL_PASS=${{ secrets.MYSQL_PASS }} \
            --from-literal=MYSQL_DB=${{ secrets.MYSQL_DB }}

      ############################################################
      # 9) Login to Docker Hub & Build/Push your image
      ############################################################
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Docker Build & Push
        uses: docker/build-push-action@v2
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/instamini:v3
          platforms: linux/amd64

      ############################################################
      # 10) Re-Configure kubectl
      ############################################################
      - name: Configure kubectl (again)
        run: |
          gcloud container clusters get-credentials vault-ha-cluster \
            --zone ${{ secrets.GCP_ZONE }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      ############################################################
      # 11) Install Argo CD & Create App
      ############################################################
      - name: Install Argo CD & Create App
        run: |
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl rollout status deployment argocd-server -n argocd --timeout=300s

          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/argocd

          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd

          ARGOCD_PW=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          argocd login argocd-server.argocd.svc.cluster.local:443 \
            --username admin \
            --password "$ARGOCD_PW" \
            --insecure --grpc-web

          argocd app create instamini \
            --repo https://github.com/casual-cat/instamini-project.git \
            --path helm/instamini \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace default \
            --sync-policy automated \
            --helm-set image.repository=${{ secrets.DOCKERHUB_USERNAME }}/instamini \
            --helm-set image.tag=v3 \
            --upsert \
            --insecure \
            --grpc-web

          argocd app wait instamini --operation --timeout=300 --insecure --grpc-web
          argocd app sync instamini --insecure --grpc-web
          argocd app wait instamini --sync --health --timeout=300 --insecure --grpc-web

      ############################################################
      # 12) Print External IP
      ############################################################
      - name: Print External IP
        run: |
          for i in {1..10}; do
            EXTERNAL_IP=$(kubectl get svc instamini-mysite -n default -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$EXTERNAL_IP" ]; then
              echo "App is accessible at: http://$EXTERNAL_IP"
              exit 0
            fi
            echo "No external IP yet, waiting 30s..."
            sleep 30
          done
          echo "No external IP assigned after 10 tries."
          exit 1
