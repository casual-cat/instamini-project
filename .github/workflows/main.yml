name: DevOps Final Project

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest
    env:
      GOOGLE_APPLICATION_CREDENTIALS: ${{ github.workspace }}/gcp-key.json

    steps:
      ############################################################
      # 1) Checkout Code
      ############################################################
      - name: Checkout repository
        uses: actions/checkout@v3

      ############################################################
      # 2) Debug listing
      ############################################################
      - name: List repository structure (debug)
        run: |
          echo "Listing root directory:"
          ls -la
          echo "Listing contents of 'terraform' folder:"
          ls -la terraform || echo "'terraform' folder not found"

      ############################################################
      # 3) Install Dependencies
      ############################################################
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y apt-transport-https ca-certificates gnupg curl jq unzip python3-pip

          # Terraform
          TF_VERSION="1.4.6"
          curl -sSL "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip" -o terraform.zip
          rm -rf tfbin
          unzip -o terraform.zip -d tfbin
          sudo mv tfbin/terraform /usr/local/bin/terraform
          sudo chmod +x /usr/local/bin/terraform
          export PATH="/usr/local/bin:$PATH"
          rm -rf tfbin terraform.zip
          terraform -version

          # Google Cloud CLI
          echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" \
            | sudo tee /etc/apt/sources.list.d/cloud-sdk.list
          curl https://packages.cloud.google.com/apt/doc/apt-key.gpg \
            | sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
          sudo apt-get update && sudo apt-get install -y google-cloud-cli

          # kubectl
          sudo apt-get install -y kubectl

          # helm
          HELM_VERSION="v3.12.0"
          curl -sSL "https://get.helm.sh/helm-${HELM_VERSION}-linux-amd64.tar.gz" -o helm.tar.gz
          tar xvf helm.tar.gz
          sudo mv linux-amd64/helm /usr/local/bin/helm
          rm -rf helm.tar.gz linux-amd64

          # Vault CLI
          VAULT_VERSION="1.14.2"
          curl -fsSL "https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_linux_amd64.zip" -o vault.zip
          unzip vault.zip
          sudo mv vault /usr/local/bin/
          rm vault.zip
          vault version

          # Python requirements
          pip3 install --upgrade pip
          pip3 install -r requirements.txt || true

      ############################################################
      # 4) GCP Auth
      ############################################################
      - name: GCP Auth
        run: |
          echo '${{ secrets.GCP_SA_KEY }}' | base64 --decode > $GITHUB_WORKSPACE/gcp-key.json
          gcloud auth activate-service-account --key-file=$GITHUB_WORKSPACE/gcp-key.json
          gcloud config set project ${{ secrets.GCP_PROJECT_ID }}

      ############################################################
      # 5) Try-Import Existing KMS Key Ring (Optional)
      ############################################################
      - name: Terraform Import Keyring
        run: |
          cd terraform
          terraform init -backend-config="bucket=tfstate-bucket-instamini" \
                         -backend-config="prefix=terraform/state"
          terraform import google_kms_key_ring.vault_ring \
            projects/instsmini-auto/locations/us-central1/keyRings/vault-ha-keyring \
            || echo "KeyRing doesn't exist or already imported"

      ############################################################
      # 6) (Optional) Test Python App
      ############################################################
      - name: Test Python App
        env:
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_PORT: ${{ secrets.MYSQL_PORT }}
          MYSQL_USER: ${{ secrets.MYSQL_USER }}
          MYSQL_PASS: ${{ secrets.MYSQL_PASS }}
          MYSQL_DB:   ${{ secrets.MYSQL_DB }}
        run: |
          python3 -m unittest discover -s tests

      ############################################################
      # 7A) Check if GKE cluster already exists
      ############################################################
      - name: Check if cluster exists
        id: clustercheck
        run: |
          EXISTING=$(gcloud container clusters list \
            --filter="name=vault-ha-cluster" --format="value(name)" || true)
          if [ "$EXISTING" == "vault-ha-cluster" ]; then
            echo "cluster_exists=true" >> $GITHUB_OUTPUT
          else
            echo "cluster_exists=false" >> $GITHUB_OUTPUT
          fi

      ############################################################
      # 7B) Conditionally Create Cluster + Node Pool
      ############################################################
      - name: Terraform Apply (Create Cluster)
        if: steps.clustercheck.outputs.cluster_exists == 'false'
        env:
          TF_VAR_gcp_project: ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_gcp_region: ${{ secrets.GCP_REGION }}
          TF_VAR_gcp_zone: ${{ secrets.GCP_ZONE }}
          TF_VAR_vault_gcp_sa_key_b64: ${{ secrets.VAULT_GCP_SA_KEY_B64 }}
          TF_VAR_kms_key_ring: ${{ secrets.KMS_KEY_RING }}
          TF_VAR_kms_crypto_key: ${{ secrets.KMS_CRYPTO_KEY }}
          TF_VAR_cloud_sql_instance_name: ${{ secrets.CLOUD_SQL_INSTANCE_NAME }}
          TF_VAR_db_root_password: ${{ secrets.DB_ROOT_PASSWORD }}
        run: |
          cd terraform
          terraform init -backend-config="bucket=tfstate-bucket-instamini" \
                         -backend-config="prefix=terraform/state"
          terraform apply \
            -target=google_container_cluster.primary \
            -target=google_container_node_pool.primary_nodes \
            -auto-approve

      ############################################################
      # 7C) Update Kubeconfig (in case cluster created or already existed)
      ############################################################
      - name: Configure Kubeconfig
        run: |
          gcloud container clusters get-credentials vault-ha-cluster \
            --zone ${{ secrets.GCP_ZONE }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      ############################################################
      # 7D) Terraform Apply (KMS + Vault, etc.)
      ############################################################
      - name: Terraform Apply (KMS + Vault)
        env:
          TF_VAR_gcp_project: ${{ secrets.GCP_PROJECT_ID }}
          TF_VAR_gcp_region: ${{ secrets.GCP_REGION }}
          TF_VAR_gcp_zone: ${{ secrets.GCP_ZONE }}
          TF_VAR_vault_gcp_sa_key_b64: ${{ secrets.VAULT_GCP_SA_KEY_B64 }}
          TF_VAR_kms_key_ring: ${{ secrets.KMS_KEY_RING }}
          TF_VAR_kms_crypto_key: ${{ secrets.KMS_CRYPTO_KEY }}
          TF_VAR_cloud_sql_instance_name: ${{ secrets.CLOUD_SQL_INSTANCE_NAME }}
          TF_VAR_db_root_password: ${{ secrets.DB_ROOT_PASSWORD }}
        run: |
          cd terraform
          terraform apply -auto-approve

      ############################################################
      # 8) Create Kubernetes MySQL Secret
      ############################################################
      - name: Create Kubernetes MySQL Secret
        run: |
          gcloud container clusters get-credentials vault-ha-cluster --zone ${{ secrets.GCP_ZONE }} --project ${{ secrets.GCP_PROJECT_ID }}
          kubectl delete secret mysite-db-secrets -n default --ignore-not-found=true
          kubectl create secret generic mysite-db-secrets -n default \
            --from-literal=MYSQL_HOST=${{ secrets.MYSQL_HOST }} \
            --from-literal=MYSQL_PORT=${{ secrets.MYSQL_PORT }} \
            --from-literal=MYSQL_USER=${{ secrets.MYSQL_USER }} \
            --from-literal=MYSQL_PASS=${{ secrets.MYSQL_PASS }} \
            --from-literal=MYSQL_DB=${{ secrets.MYSQL_DB }}

      ############################################################
      # 9) Docker Build & Push
      ############################################################
      - name: Docker Build & Push
        uses: docker/build-push-action@v2
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/instamini:v3
          platforms: linux/amd64
        env:
          DOCKER_LOGIN_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKER_LOGIN_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}

      ############################################################
      # 10) Re-Configure kubectl
      ############################################################
      - name: Configure kubectl (again)
        run: |
          gcloud container clusters get-credentials vault-ha-cluster --zone ${{ secrets.GCP_ZONE }} --project ${{ secrets.GCP_PROJECT_ID }}

      ############################################################
      # 11) Install Argo CD & Create App
      ############################################################
      - name: Install Argo CD & Create App
        run: |
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl rollout status deployment argocd-server -n argocd --timeout=300s

          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/argocd

          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd

          ARGOCD_PW=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          argocd login argocd-server.argocd.svc.cluster.local:443 --username admin --password "$ARGOCD_PW" --insecure --grpc-web

          argocd app create instamini \
            --repo https://github.com/casual-cat/instamini-project.git \
            --path helm/instamini \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace default \
            --sync-policy automated \
            --helm-set image.repository=${{ secrets.DOCKERHUB_USERNAME }}/instamini \
            --helm-set image.tag=v3 \
            --upsert \
            --insecure \
            --grpc-web

          argocd app wait instamini --operation --timeout=300 --insecure --grpc-web
          argocd app sync instamini --insecure --grpc-web
          argocd app wait instamini --sync --health --timeout=300 --insecure --grpc-web

      ############################################################
      # 12) Print External IP
      ############################################################
      - name: Print External IP
        run: |
          for i in {1..10}; do
            EXTERNAL_IP=$(kubectl get svc instamini-mysite -n default -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$EXTERNAL_IP" ]; then
              echo "App is accessible at: http://$EXTERNAL_IP"
              exit 0
            fi
            echo "No external IP yet, waiting 30s..."
            sleep 30
          done
          echo "No external IP assigned after 10 tries."
          exit 1
